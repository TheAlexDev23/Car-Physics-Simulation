using System.Collections.Generic;
using UnityEngine;
using TMPro;

public class MainCarSimulationScript : MonoBehaviour {
    private Rigidbody cmp_rb;
    public void Start() {
        cmp_rb = GetComponent<Rigidbody>();
        cnst_Cdrag = 0.4257f; //0.5 * 0.30 * 2.2 * 1.29.  
        cnst_Crr   = 12.8f;   //30 * Cdrag

        GetWheels();

        Time.fixedDeltaTime /= 5;
    }

    private GameObject go_WheelsParentGameObject;
    private List<GameObject> go_wheelsGameObjects = new List<GameObject>();
 
    private void GetWheels() {
        go_WheelsParentGameObject = GameObject.Find("Wheels");
        foreach (Transform wheel in go_WheelsParentGameObject.transform) {
            go_wheelsGameObjects.Add(wheel.gameObject);
        }
    }

    public void FixedUpdate() {
        SimulatePhyisics();
    }

    [HideInInspector] public Vector3 Ftraction; //Traction generated by wheels rolling on the surface
    [HideInInspector] public Vector3 Fdrag; //Air resistance
    [HideInInspector] public Vector3 Frr; //Rolling resistance
    [HideInInspector] public Vector3 Fbraking; //Braking force
    [HideInInspector] public Vector3 Flong; //The total longtitudinal force
    
    [SerializeField]  private int var_rpm; //Max RPM
    [SerializeField]  private int var_accelerationRpmMultiplier; //RPM added per second when fully pressed "W" key
    [HideInInspector] public int _var_rpm; //Current RPM
    [SerializeField]  private AnimationCurve var_RpmToTorque; //Conversion curve between RPM and torque
    [HideInInspector] public float _var_EngineForce; //Curent torque force applied to the car
    [HideInInspector] public bool var_isBraking;
    [SerializeField]  private int var_turboBoostAmount; //When boosting this would be added to accelerationRpmMultiplier 
    
    private float cnst_Cdrag; //Air resistance constant
    private float cnst_Crr; //Rolling resisteance constant
    [SerializeField]
    private float cnst_Cbraking; //Braking constant

    private void SimulatePhyisics() {
        var u = transform.forward; 
        var velocity = cmp_rb.velocity;

        if (_var_rpm > 0) 
            _var_EngineForce = 1000 * var_RpmToTorque.Evaluate(_var_rpm / 1000);
        else
            _var_EngineForce = -1000 * var_RpmToTorque.Evaluate(-_var_rpm / 1000); //because our graph doesn't have results for negative values, this needs to be done

        //Calculation of forces
        Ftraction = _var_EngineForce * u; //Traction is the main force generated by the wheels
        Fdrag     = -cnst_Cdrag * velocity * velocity.magnitude;  //Drag is the air resistance
        Frr       = -cnst_Crr * velocity; //Rolling Resistance is the resistance caused by the friction of the wheels with the ground

        if(var_isBraking)
            Fbraking  = -cmp_rb.velocity / 5 * cnst_Cbraking * Mathf.Clamp(cmp_rb.velocity.magnitude, 0, 1); //if velocity is 0, then braking force would also be 0 on all axis
        else 
            Fbraking = Vector3.zero;
        
        Flong = Ftraction + Fdrag + Frr + Fbraking;

        if(Input.GetAxis("Horizontal") != 0) cmp_rb.AddForce(go_wheelsGameObjects[3].transform.forward * _var_EngineForce + Frr);
        cmp_rb.AddForce(Flong);
    }

    private void SimulateCarRotation() {
        var angleMultiplier = 0;
        var directionAngleMultiplier = 0;

        if (Input.GetAxis("Horizontal") < 0) angleMultiplier = -1;
        if (Input.GetAxis("Horizontal") > 0) angleMultiplier = 1;

        if (Input.GetAxis("Vertical") >= 0) directionAngleMultiplier = 1;
        if (Input.GetAxis("Vertical") < 0)  directionAngleMultiplier = -1;

        var _angle = Vector3.Angle(transform.forward, go_wheelsGameObjects[3].transform.forward) * angleMultiplier * directionAngleMultiplier;
        
        var rotationVector = new Vector3(0, _angle, 0);

        float speedRotationMultiplier = 0;
        if (cmp_rb.velocity.magnitude > 1) speedRotationMultiplier = .65f;
        if (cmp_rb.velocity.magnitude > 5) speedRotationMultiplier = 1;
        if (cmp_rb.velocity.magnitude > 10) speedRotationMultiplier = 1.5f;
        if (cmp_rb.velocity.magnitude > 45) speedRotationMultiplier = 1f;
        if (cmp_rb.velocity.magnitude > 90) speedRotationMultiplier = .5f;

        transform.Rotate(rotationVector * Time.deltaTime * speedRotationMultiplier);
    }

    private void UpdateWheelAngle() {
        go_WheelsParentGameObject.transform.position = transform.position;
        go_WheelsParentGameObject.transform.rotation = transform.rotation;

        var Horizontal = Mathf.Clamp(Input.GetAxis("Horizontal"), -0.85f, 0.85f);

        var angle = 90 - Mathf.Acos(Horizontal) * Mathf.Rad2Deg;

        if((int)angle == 0) angle = 0;

        var wheelRotationVector = new Vector3(0, angle, 0);

        go_wheelsGameObjects[2].transform.localEulerAngles = go_wheelsGameObjects[3].transform.localEulerAngles = wheelRotationVector;
    }

    private void GetRpmAndTorque() {
        _var_rpm += (int)(var_accelerationRpmMultiplier * Input.GetAxis("Vertical") * Time.deltaTime);
        _var_rpm = Mathf.Clamp(_var_rpm, -var_rpm, var_rpm);

        if (Input.GetAxis("Vertical") == 0 && _var_rpm > 0) _var_rpm -= (int)(var_accelerationRpmMultiplier * Time.deltaTime);
        if (Input.GetAxis("Vertical") == 0 && _var_rpm < 0) _var_rpm += (int)(var_accelerationRpmMultiplier * Time.deltaTime);
    }
   
    public void Update() {
        UpdateWheelAngle();
        SimulateCarRotation();
        GetRpmAndTorque();
        
        if (Input.GetKeyDown(KeyCode.Space)) 
            var_isBraking = true;
        if (Input.GetKeyUp(KeyCode.Space))
            var_isBraking = false;

        if (Input.GetKeyDown(KeyCode.LeftShift)) 
            var_accelerationRpmMultiplier += var_turboBoostAmount;
        if (Input.GetKeyUp(KeyCode.LeftShift)) 
            var_accelerationRpmMultiplier -= var_turboBoostAmount;
    }
}
